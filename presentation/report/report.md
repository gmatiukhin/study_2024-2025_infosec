---
## Front matter
title: "Ошибки проверки вводимых данных: инъекция кода"
subtitle: "Реферат"
author: "Матюхин Григорий Васильевич"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Введение

Инъекции кода представляют собой класс уязвимостей в компьютерной безопасности,
при которых уязвимая программа неверно интерпретирует внешние данные
(чаще всего ввод пользователя) как часть собственного кода.
Таким образом, злоумышленник "внедряет" код в программу, изменяя ход её выполнения.
Успешная инъекция кода может иметь серьёзные последствия,
например, способствовать распространению компьютерных вирусов или червей.

Уязвимости инъекций кода возникают, когда приложение передаёт ненадёжные данные интерпретатору.
Подобные ошибки часто встречаются в запросах SQL, LDAP, XPath, NoSQL,
командах операционной системы, парсерах XML, заголовках SMTP, аргументах программ и других местах.
Уязвимости инъекций легче обнаружить при анализе исходного кода, чем при тестировании.
Статический анализ и фазы могут помочь выявить такие уязвимости[@owasp_top10_2013].

## Последствия

Инъекции кода могут привести к потере или повреждению данных,
отсутствию отслеживаемости, отказу в доступе,
а в некоторых случаях - к полному захвату контроля над хостом.

Определённые виды инъекций кода являются ошибками интерпретации,
при которых ввод пользователя получает особое значение.

Техники инъекций кода популярны среди хакеров и взломщиков для получения информации,
повышения привилегий или несанкционированного доступа к системе.
Инъекции кода могут использоваться с различными злонамеренными целями, включая:

- Произвольное изменение значений в базе данных через инъекцию SQL.
    Это может привести как к порче веб-сайта, так и к серьёзным компрометирующим утечкам конфиденциальных данных.
- Установку вредоносного ПО или выполнение зловредного кода на сервере
    путём инъекции серверного скриптового кода (например, PHP или ASP).
- Повышение привилегий до уровня root, эксплуатируя уязвимости инъекции
    в оболочку в бинарных файлах с правами setuid root на UNIX или привилегии
    Local System через эксплуатацию сервиса на Microsoft Windows.
- Атаки на веб-пользователей с помощью инъекций HTML/скриптов (межсайтовый скриптинг, XSS).

Инъекции кода, направленные на устройства Интернета вещей (IoT),
также могут привести к серьёзным последствиям, таким как утечки данных и сбои в предоставлении услуг[@noman2023code].

# Доброкачественное и непреднамеренное использование

Инъекция кода может быть выполнена с добрыми намерениями.
Например, изменение или корректировка поведения программы
или системы с помощью инъекции кода может заставить систему
работать определённым образом без злонамеренных целей.
Инъекция кода может, например:

- Добавить полезный новый столбец, который не был предусмотрен в оригинальном дизайне страницы с результатами поиска.
- Предложить новый способ фильтрации, сортировки или группировки данных с использованием поля,
    которое не было доступно в исходных функциях дизайна.
- В программе, подобной Dropbox, добавить специальные компоненты,
    которые могут использоваться для подключения к онлайн-ресурсам в оффлайн-программе.
- Использовать динамический линкер Linux для определения функции с тем же именем,
    что и определённые функции библиотеки Libc,
    подключить эту функцию как библиотеку и переопределить использование функций Libc[@cieslak2013dynamic_linker].

Некоторые пользователи могут непреднамеренно выполнить инъекцию кода,
потому что ввод, который они предоставили программе,
не был предусмотрен разработчиками системы. Например:

- То, что пользователь считает допустимым вводом, может содержать символы или строковые маркеры,
    зарезервированные разработчиками для специального значения
    (например, символ "&" в "Shannon & Jason" или кавычки в "Bob 'Slugger' McCracken").
- Пользователь может отправить некорректный файл в качестве ввода,
    который нормально обрабатывается в одной программе, но становится проблемным для другой системы.

Ещё одно безобидное применение инъекции кода - это обнаружение уязвимостей инъекций с целью их исправления.
Это известно как тестирование на проникновение "белых хакеров".

# Примеры инъекции кода

## Межсайтовый скриптинг (XSS)

XSS (Cross-Site Scripting)[@owasp_xss] -- это тип уязвимости веб-приложений,
который позволяет злоумышленнику внедрить вредоносный код (обычно JavaScript)
в веб-страницу, которую просматривают другие пользователи.
Эта уязвимость возникает, когда приложение небезопасно обрабатывает
ввод данных и выводит его без должной фильтрации или экранирования.
XSS позволяет атакующему выполнять произвольные скрипты в браузере жертвы,
что может привести к краже данных, захвату сессий или выполнению других нежелательных действий.

### Виды XSS:
1. Reflected XSS (отражённый XSS):
   - Происходит, когда вредоносный скрипт внедряется в запрос
       и немедленно отражается на странице без сохранения в базе данных.
   - Пример:
     - Злоумышленник отправляет жертве ссылку на веб-сайт с параметром `search`,
         содержащим вредоносный код:
     ```html
     https://example.com/search?q=<script>alert('XSS');</script>
     ```
     - Когда жертва переходит по ссылке, сервер возвращает страницу с результатами поиска,
         содержащими вредоносный скрипт.

2. Stored XSS (сохранённый XSS):
   - Вредоносный код сохраняется на сервере (например, в базе данных)
       и отображается другим пользователям при просмотре скомпрометированных данных.
   - Пример:
     - Злоумышленник оставляет комментарий на сайте с внедрённым JavaScript-кодом:
     ```html
     <script>alert('Your session is hijacked');</script>
     ```
     - Этот код будет выполняться всякий раз,
     когда другие пользователи просматривают этот комментарий.

3. DOM-based XSS:
   - Уязвимость возникает непосредственно в клиентской части (в браузере),
       когда JavaScript на странице небезопасно обрабатывает данные
       из URL или других источников.
   - Пример:
     - Страница использует JavaScript для динамического изменения DOM на основе данных в URL:
     ```javascript
     document.write(location.href);
     ```
     - Если пользователь перейдёт по ссылке:
     ```html
     https://example.com/#<script>alert('DOM XSS');</script>
     ```
     - Вредоносный скрипт будет выполнен в контексте страницы.

## Инъекция команд

Инъекция в оболочку (или инъекция команд[@owasp_command_injection])
названа в честь оболочек Unix, но применяется ко многим системам,
которые позволяют программно выполнять командную строку.
Вот пример уязвимого bash-скрипта:

```bash
#!/bin/bash
if [ $1 == 1 ]; then echo "it matches"; fi
```

Если этот скрипт сохранён в исполняемом файле ./check, команда

```bash
$ ./check.sh "$(evil_command; echo 1)"
```

попытается выполнить внедрённую команду `evil_command`
перед сравнением аргумента с константой "1".
Здесь уязвимая часть кода - это проверка параметра,
которая, возможно, предназначалась для защиты от атак, но сама стала целью инъекции.

Любая функция, которая может составлять и выполнять команду оболочки,
потенциально уязвима для атак через инъекцию в оболочку.

Например:
- `subprocess.run()` в Python
- `system()` в C
- `std::process::Command::new()` в Rust
- `exec.Command()` в Java

Некоторые языки программирования предоставляют функции
для правильного экранирования или заключения в кавычки строк,
используемых для составления команд оболочки:

- `shlex.quote()` в Python
- `Shellwords.escape()` в Ruby
- `shlex::quote()` в Rust
- `StringEscapeUtils.escapeJava()` в Java

Однако это по-прежнему возлагает ответственность на программистов
за знание и правильное использование этих функций каждый раз при работе с командами оболочки.
Помимо использования этих функций, рекомендуется также проводить валидацию
или очистку пользовательского ввода.

Более безопасной альтернативой является использование API,
которые выполняют внешние программы напрямую, без использования оболочки,
что предотвращает возможность инъекций в оболочку.
Однако такие API часто не поддерживают удобные функции оболочек
или могут быть более громоздкими по сравнению с кратким синтаксисом оболочки.

## Чтение стека format-строкой

Ошибка форматной строки появляется чаще всего,
когда программист хочет вывести строку, содержащую данные, предоставленные пользователем.
Программист может ошибочно написать `printf(buffer)` вместо `printf("%s", buffer)`.
В первой версии `buffer` интерпретируется как строка формата,
и парсятся любые инструкции форматирования, которые она может содержать.
Вторая версия просто выводит строку на экран, как и предполагал программист.

Рассмотрим следующую короткую программу на C,
в которой есть локальная переменная - массив символов `char password[10]`, содержащий пароль;
программа запрашивает у пользователя строку,
а затем выводит ее на экран.

```c
#include <stdio.h>

int main() {
    char user_input[100];
    char password[10] = "Password1";

    fgets(user_input, sizeof(user_input), stdin);

    printf(user_input); // Safe version is: printf("%s", user_input);
    printf("\n");

    return 0;
}
```

Если ввод пользователя содержит список спецификаторов формата,
таких как `%x%x%x%x%x%x%x%x`, то функция `printf()` начнет считывать данные из стека[@cwe_134].
В конечном итоге если заменить один из `%x` на `%s` то он получит доступ к адресу переменной `password`,
которая находится на стеке, и выведет на экран значение `Password1`.

# Устранение инъекций

Для предотвращения проблем с инъекциями кода следует применять стратегии
безопасной обработки ввода и вывода, такие как:

- Использование API, которые, при правильном использовании, защищены от всех вводимых символов.
    Параметризованные запросы (также известные как "составные запросы")
    позволяют отделить пользовательские данные от строк для интерпретации.
- Валидация или "санитарная" очистка ввода, например,
    создание белого списка известных допустимых значений.
    Это можно сделать на стороне клиента (что подвержено модификации злоумышленниками)
    или на стороне сервера (что более безопасно).
- Кодирование ввода, например, экранирование опасных символов.
    Например, в PHP можно использовать функцию `htmlspecialchars()`
    для экранирования специальных символов при безопасном выводе текста в HTML,
    а функцию `mysqli::real_escape_string()` для изоляции данных в SQL-запросах
    для защиты от SQL-инъекций.
- Кодирование вывода, чтобы предотвратить атаки инъекций HTML (XSS) против посетителей сайта.
- Установка флага `HttpOnly` для HTTP Cookies,
    который не позволяет клиентским скриптам взаимодействовать с куками,
    предотвращая определенные XSS-атаки[@owasp_httponly].

Перечисленные выше решения в основном направлены на защиту веб-приложений
от инъекций HTML или скриптов в серверные приложения.
Однако другие подходы требуются для борьбы с инъекциями пользовательского кода на пользовательской машине,
которые могут привести к повышению привилегий.
Некоторые методы для обнаружения и изоляции управляемых и неуправляемых инъекций кода включают:

- Валидация хешей образа в реальном времени - создание хеша части или полного образа исполняемого файла,
    загруженного в память, и его сравнение с сохранённым и ожидаемым хешем.
- Использование бита NX - все пользовательские данные хранятся в специальных разделах памяти,
    помеченных как неисполняемые. Процессор распознает, что в этой части памяти нет кода,
    и отказывается выполнять всё, что там обнаружено.
- "Канарейки" - случайное размещение значений в стеке.
    Во время выполнения программы проверяется значение канарейки при возврате функции.
    Если оно изменено, программа прекращает выполнение и завершает работу.
    Это защита от атак переполнения стека.
- Маскирование указателей на код (CPM) в C -
    после загрузки (возможно изменённого) указателя на код в регистр применяется
    битовая маска к указателю, что эффективно ограничивает адреса, на которые он может ссылаться[@philippaerts2013cpm].

# Выводы

В этом докладе мы рассмотрели уязвимости, связанные с инъекцией кода,
которые представляют собой значительную угрозу для безопасности компьютерных систем.
Инъекции кода могут принимать различные формы, такие как инъекции команд и XSS, и возникают,
когда ненадежные данные обрабатываются без должной проверки.
Мы обсудили последствия успешной инъекции кода, включая утечку данных,
повреждение информации и несанкционированный доступ к системам.
Также были рассмотрены методы предотвращения таких уязвимостей,
включая использование безопасных методов обработки ввода и выхода,
а также применение статического анализа кода.
Несмотря на известные риски, понимание и реализация эффективных стратегий защиты
могут существенно снизить вероятность атак, связанных с инъекцией кода.

# Список литературы{.unnumbered}
::: {#refs}
:::
